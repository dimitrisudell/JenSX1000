/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "JenConstants.h"

#include "JenParameter.h"


//==============================================================================
JenSx1000AudioProcessor::JenSx1000AudioProcessor() :
ampEnvelope(JenConstants::AmpEnvMaxAttackTime, JenConstants::AmpEnvMaxDecayTime, JenConstants::AmpEnvMaxReleaseTime)

{
    //Run Unit tests
    if (true){
        std::cout << "processor created";
        UnitTestRunner runner;
        runner.runAllTests();
    }
    
    //------- VCO Params -------------------------------------------------------
    addParameter(vcoTuneParam = new JenParameter(*this, "VCO tune", 0.5));
    addParameter(vcoOctaveParam = new JenParameter(*this, "VCO octave", 0, 4));
    addParameter(vcoVibratoParam = new JenParameter(*this, "VCO vibrato", 0.5));
    addParameter(vcoWaveformParam = new JenParameter(*this, "VCO waveform", 0.5, 3));
    addParameter(vcoPulseWidthParam = new JenParameter(*this, "VCO pulse width", 0.5));
    addParameter(vcoPWMParam = new JenParameter(*this, "VCO PWM", 0.5));
    addParameter(vcoLevelParam = new JenParameter(*this, "VCO level", 0.5));
    addParameter(vcoGlideParam = new JenParameter(*this, "VCO glide", 0.5));
    
    //------- LFO Params ------------------------------------------------------
    addParameter(lfoSpeedParam = new JenParameter(*this, "LFO speed", 0.5));
    
    //------- VCF Params ------------------------------------------------------
    addParameter(vcfFrequencyParam = new JenParameter(*this, "VCF frequency", 0.5));
    addParameter(vcfResonanceParam = new JenParameter(*this, "VCF resonance", 0.5));
    addParameter(vcfLFOParam = new JenParameter(*this, "VCF LFO", 0.5));
    addParameter(vcfEnvLevelParam = new JenParameter(*this, "VCF env. level", 0.5));
    addParameter(vcfAttackParam = new JenParameter(*this, "VCF attack", 0.3));
    addParameter(vcfDecayParam = new JenParameter(*this, "VCF decay", 0.3));
    addParameter(vcfSustainParam = new JenParameter(*this, "VCF sustain", 0.5));
    addParameter(vcfReleaseParam = new JenParameter(*this, "VCF release", 0.3));
    
    //------- Noise Params ----------------------------------------------------
    addParameter(noiseNoiseParam = new JenParameter(*this, "NOISE noise", 0.5, 3));
    addParameter(noiseLevelParam = new JenParameter(*this, "NOISE level", 0.5));
    
    //------- VCA Params ------------------------------------------------------
    addParameter(vcaOutputVolumeParam = new JenParameter(*this, "VCA level", 0.5));
    addParameter(vcaAttackParam = new JenParameter(*this, "VCA attack", 0.3));
    addParameter(vcaDecayParam = new JenParameter(*this, "VCA decay", 0.3));
    addParameter(vcaSustainParam = new JenParameter(*this, "VCA sustain", 0.5));
    addParameter(vcaReleaseParam = new JenParameter(*this, "VCA release", 0.3));
    
    setCurrentProgram(0);
}

JenSx1000AudioProcessor::~JenSx1000AudioProcessor()
{
}

//==============================================================================
const String JenSx1000AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String JenSx1000AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String JenSx1000AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool JenSx1000AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool JenSx1000AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool JenSx1000AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool JenSx1000AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool JenSx1000AudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double JenSx1000AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int JenSx1000AudioProcessor::getNumPrograms()
{
    return (int)FactoryPrograms::Programs::FACTORY_PROGRAMS_COUNT;
    // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int JenSx1000AudioProcessor::getCurrentProgram()
{
    return currentProgram;
}

void JenSx1000AudioProcessor::setCurrentProgram (int index)
{
    currentProgram = index;
    Program* p = programs.getProgramPointer((FactoryPrograms::Programs)index);
    setProgram(p);
}

void JenSx1000AudioProcessor::setProgram (Program* p){
    
    vcoTuneParam->setValueNotifyingHost (p->vcoTune);
    vcoOctaveParam->setValueNotifyingHost (p->vcoOctave);
    vcoVibratoParam->setValueNotifyingHost (p->vcoVibrato);
    vcoWaveformParam->setValueNotifyingHost (p->vcoWaveform);
    vcoPulseWidthParam->setValueNotifyingHost (p->vcoPulseWidth);
    vcoPWMParam->setValueNotifyingHost (p->vcoPWM);
    vcoLevelParam->setValueNotifyingHost (p->vcoLevel);
    vcoGlideParam->setValueNotifyingHost (p->vcoGlide);
    
    //------- LFO --------------------------------------------------------------
    lfoSpeedParam->setValueNotifyingHost (p->lfoSpeed);
    
    //------- VCF --------------------------------------------------------------
    vcfFrequencyParam->setValueNotifyingHost (p->vcfFrequency);
    vcfResonanceParam->setValueNotifyingHost (p->vcfResonance);
    vcfLFOParam->setValueNotifyingHost (p->vcfLFO);
    vcfEnvLevelParam->setValueNotifyingHost (p->vcfEnvLevel);
    vcfAttackParam->setValueNotifyingHost (p->vcfAttack);
    vcfDecayParam->setValueNotifyingHost (p->vcfDecay);
    vcfSustainParam->setValueNotifyingHost (p->vcfSustain);
    vcfReleaseParam->setValueNotifyingHost (p->vcfRelease);
    
    //------- Noise ------------------------------------------------------------
    noiseNoiseParam->setValueNotifyingHost (p->noiseNoise);
    noiseLevelParam->setValueNotifyingHost (p->noiseLevel);
    
    //------- VCA --------------------------------------------------------------
    vcaOutputVolumeParam->setValueNotifyingHost (p->vcaOutputVolume);
    vcaAttackParam->setValueNotifyingHost (p->vcaAttack);
    vcaDecayParam->setValueNotifyingHost (p->vcaDecay);
    vcaSustainParam->setValueNotifyingHost (p->vcaSustain);
    vcaReleaseParam->setValueNotifyingHost (p->vcaRelease);
}

const String JenSx1000AudioProcessor::getProgramName (int index)
{
    return programs.getProgramPointer((FactoryPrograms::Programs)index) -> programName;
}

void JenSx1000AudioProcessor::changeProgramName (int index, const String& newName)
{
    programs.getProgramPointer((FactoryPrograms::Programs)index) -> programName = newName;
}

//==============================================================================
void JenSx1000AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    DBG("\n-- JenSx1000AudioProcessor::prepareToPlay called\n");
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    
    DBG("Sample Rate : " << sampleRate << "\n");
    DBG("Expected samples per block: " << samplesPerBlock << "\n");
    
    currentSampleRate = sampleRate;
    
    oscillator.updateSampleRate(currentSampleRate);
    lfo.updateSampleRate(currentSampleRate);
    ampEnvelope.setSampleRate(currentSampleRate);
    vcf.setSampleRate(currentSampleRate);
    freqControl.setSampleRate(currentSampleRate);
    noClick.setSampleRate(currentSampleRate);
}

void JenSx1000AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void JenSx1000AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    int time;
    MidiMessage m;
    
    for (MidiBuffer::Iterator i (midiMessages); i.getNextEvent (m, time);)
    {
        if (m.isNoteOn())
        {
            int lastMidiNote = m.getNoteNumber();
            DBG("MIDI note triggered : " << lastMidiNote << "\n");
            heldNotes.insert(lastMidiNote);
        }
        else if (m.isNoteOff())
        {
            int releasedNote = m.getNoteNumber();
            DBG("MIDI note released : " << releasedNote << "\n");
            heldNotes.erase(releasedNote);
        }
        else if (m.isAftertouch())
        {
        }
        else if (m.isPitchWheel())
        {
        }
    }
    
    int highestHeldNote;
    
    if (heldNotes.empty()){
        if (currentNote > 0){
            DBG("Note released");
            ampEnvelope.release();
            vcf.release();
            currentNote = -1000;
            nextNote = -2000;
        }
    } else {
        highestHeldNote = *heldNotes.rbegin();
        if (nextNote != highestHeldNote){
            nextNote = highestHeldNote;
            noClick.start();
        }
    }
    
    
    std::vector<float*> ChannelData;
    
    for (int i = 0; i < getNumOutputChannels(); i++){
        ChannelData.push_back(buffer.getWritePointer(i));
    }
    
    for (int sample = 0; sample < buffer.getNumSamples(); ++sample){
        
        if (!heldNotes.empty() && currentNote != nextNote && noClick.fadingIn()){
            currentNote = nextNote;
            freqControl.setNote(currentNote);
            ampEnvelope.begin();
            vcf.begin();
        }
        
        float nextLFOSample = lfo.getNextSample();
        freqControl.setNextVibratoOscSample(nextLFOSample);
        vcf.setNextLFOSample(nextLFOSample);
        oscillator.setNextPWMSample(nextLFOSample);
        float nextNoClickSample = noClick.getNextSample();
        
        oscillator.updateFrequency(freqControl.getNextFrequency());
        
        float nextOscSample = oscillator.getNextSample();
        float nextNoiseSample = noise.getNextSample();
        float nextAmpSample = ampEnvelope.getNextSample();
        
        
        float nextSample = (vcf.processNextSample((nextOscSample * vcoLevel) + (nextNoiseSample * noiseLevel)) * nextAmpSample) * ampLevel *nextNoClickSample;
        
        for (float* channel : ChannelData){
            channel[sample] = nextSample;
        }
    }
}

//==============================================================================
bool JenSx1000AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* JenSx1000AudioProcessor::createEditor()
{
    DBG("\n-- JenSx1000AudioProcessor::createEditor called\n");
    return new JenSx1000AudioProcessorEditor (*this);
}

void JenSx1000AudioProcessor::parameterChange(AudioProcessorParameter* param, float newValue){
    if (param == vcoTuneParam) {freqControl.setTuning((newValue * 2) - 1);}
    else if (param == vcoOctaveParam) {
        if (newValue == 1){freqControl.setOctave(FreqControl::FOUR);}
        else if (newValue > 0.66){freqControl.setOctave(FreqControl::EIGHT);}
        else if (newValue > 0.33){freqControl.setOctave(FreqControl::SIXTEEN);}
        else if (newValue == 0){freqControl.setOctave(FreqControl::THIRTY_TWO);}
        else {DBG("OCTAVE SETTING NOT KNOWN"); jassertfalse;}
    }
    else if (param == vcoVibratoParam) {freqControl.setVibratoValue(newValue * JenConstants::VibratoMax);}
    else if (param == vcoWaveformParam) {
        if (newValue == 0){oscillator.updateWave(Oscillator::SAW);}
        else if (newValue == 0.5){oscillator.updateWave(Oscillator::SQUARE);}
        else if (newValue == 1){oscillator.updateWave(Oscillator::PULSE);}
        else {DBG("WAVEFORM SETTING NOT KNOWN: " + (String)newValue + "\n"); jassertfalse;}
    }
    else if (param == vcoPulseWidthParam) {oscillator.setPulseWidth((JenConstants::PulseWidthMin + ((1 - newValue) * JenConstants::pulseWidthRange)));}
    else if (param == vcoPWMParam) {oscillator.setPWMamount(((pow(30, newValue) - 1)) / 29);}
    else if (param == vcoLevelParam) { vcoLevel = (newValue * 0.5); }
    else if (param == vcoGlideParam) { freqControl.setGlideValue(((pow(30, newValue) - 1)) / 29);}
    else if (param == lfoSpeedParam) {
        float lfoFrequency = FreqControl::getMidiNoteInHertz((JenConstants::LfoMinSpeed + (newValue * JenConstants::LfoSpeedRange)));
        DBG("New LFO speed: " + (String)lfoFrequency); lfo.updateFrequency(lfoFrequency);
    }
    else if (param == vcfFrequencyParam) {vcf.setCutoff(((pow(30, newValue) - 1)) / 29);}
    else if (param == vcfResonanceParam) {vcf.setResonance(newValue);}
    else if (param == vcfLFOParam) {vcf.setLFOAmount(newValue);}
    else if (param == vcfEnvLevelParam) {vcf.setEnvLevel(newValue);}
    else if (param == vcfAttackParam) {vcf.setAttackValue(((pow(30, newValue) - 1)) / 29);}
    else if (param == vcfDecayParam) {vcf.setDecayValue(((pow(30, newValue) - 1)) / 29);}
    else if (param == vcfSustainParam) {vcf.setSustainAmplitude(newValue);}
    else if (param == vcfReleaseParam) {vcf.setReleaseValue(((pow(30, newValue) - 1)) / 29);}
    else if (param == noiseNoiseParam) {
        if (newValue == 0) {noise.setState(NoiseGen::OFF);}
        else if (newValue == 0.5) {noise.setState(NoiseGen::WHITE);}
        else if (newValue == 1) {noise.setState(NoiseGen::PINK);}
        else {DBG("NOISE SETTING NOT KNOWN: " + (String)newValue + "\n"); jassertfalse;}
    }
    else if (param == noiseLevelParam) {noiseLevel = newValue * 0.5;}
    else if (param == vcaOutputVolumeParam){ ampLevel = newValue; }
    else if (param == vcaAttackParam) {ampEnvelope.setAttackValue(((pow(30, newValue) - 1)) / 29);}
    else if (param == vcaDecayParam) {ampEnvelope.setDecayValue(((pow(30, newValue) - 1)) / 29);}
    else if (param == vcaSustainParam) {ampEnvelope.setSustainAmplitude(newValue);}
    else if (param == vcaReleaseParam) {ampEnvelope.setReleaseValue(((pow(30, newValue) - 1)) / 29);}
}

//==============================================================================
void JenSx1000AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    Program currentProgram("Current Program");
    
    currentProgram.vcoTune = vcoTuneParam->getValue();
    currentProgram.vcoOctave = vcoOctaveParam->getValue();
    currentProgram.vcoVibrato = vcoVibratoParam->getValue();
    currentProgram.vcoWaveform = vcoWaveformParam->getValue();
    currentProgram.vcoPulseWidth = vcoPulseWidthParam->getValue();
    currentProgram.vcoPWM = vcoPWMParam->getValue();
    currentProgram.vcoLevel = vcoLevelParam->getValue();
    currentProgram.vcoGlide = vcoGlideParam->getValue();
    currentProgram.lfoSpeed = lfoSpeedParam->getValue();
    currentProgram.vcfFrequency = vcfFrequencyParam->getValue();
    currentProgram.vcfResonance = vcfResonanceParam->getValue();
    currentProgram.vcfLFO = vcfLFOParam->getValue();
    currentProgram.vcfEnvLevel = vcfEnvLevelParam->getValue();
    currentProgram.vcfAttack = vcfAttackParam->getValue();
    currentProgram.vcfDecay = vcfDecayParam->getValue();
    currentProgram.vcfSustain = vcfSustainParam->getValue();
    currentProgram.vcfRelease = vcfReleaseParam->getValue();
    currentProgram.noiseNoise = noiseNoiseParam->getValue();
    currentProgram.noiseLevel = noiseLevelParam->getValue();
    currentProgram.vcaOutputVolume = vcaOutputVolumeParam->getValue();
    currentProgram.vcaAttack = vcaAttackParam->getValue();
    currentProgram.vcaDecay = vcaDecayParam->getValue();
    currentProgram.vcaSustain = vcaSustainParam->getValue();
    currentProgram.vcaRelease = vcaReleaseParam->getValue();
    
    copyXmlToBinary (currentProgram.getProgrameAsXmlElement(), destData);
}

void JenSx1000AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    
    Program* newProgram = new Program("New Program");
    
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    newProgram -> setProgramFromXml(xmlState);
    
    setProgram(newProgram);
    
    
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JenSx1000AudioProcessor();
}


