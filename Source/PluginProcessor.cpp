/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

#include "JenParameter.h"


//==============================================================================
JenSx1000AudioProcessor::JenSx1000AudioProcessor()
{
    //Run Unit tests
    if (true){
        std::cout << "processor created";
        UnitTestRunner runner;
        runner.runAllTests();
    }
    
    //------- VCO Params -------------------------------------------------------
    
    addParameter(vcoTuneParam = new JenParameter(*this, "VCO tune", 0.5));
    vcoTuneParam->setValueNotifyingHost(0.5);
    
    addParameter(vcoOctaveParam = new JenParameter(*this, "VCO octave", 0, 4));
    vcoOctaveParam->setValueNotifyingHost(0.67);
    
    addParameter(vcoVibratoParam = new JenParameter(*this, "VCO vibrato", 0.5));
    vcoVibratoParam->setValueNotifyingHost(0.5);
    
    addParameter(vcoWaveformParam = new JenParameter(*this, "VCO waveform", 0.5, 3));
    vcoWaveformParam->setValueNotifyingHost(0.5);
    
    addParameter(vcoPulseWidthParam = new JenParameter(*this, "VCO pulse width", 0.5));
    vcoPulseWidthParam->setValueNotifyingHost(0.5);
    
    addParameter(vcoPWMParam = new JenParameter(*this, "VCO PWM", 0.5));
    vcoPWMParam->setValueNotifyingHost(0.5);
    
    addParameter(vcoLevelParam = new JenParameter(*this, "VCO level", 0.5));
    vcoLevelParam->setValueNotifyingHost(0.5);
    
    addParameter(vcoGlideParam = new JenParameter(*this, "VCO glide", 0.5));
    vcoGlideParam->setValueNotifyingHost(0.5);
    
    //------- LFO Params ------------------------------------------------------
    
    addParameter(lfoSpeedParam = new JenParameter(*this, "LFO speed", 0.5));
    lfoSpeedParam->setValueNotifyingHost(0.5);
    
    //------- VCF Params ------------------------------------------------------
    
    addParameter(vcfFrequencyParam = new JenParameter(*this, "VCF frequency", 0.5));
    vcfFrequencyParam->setValueNotifyingHost(0.5);
    
    addParameter(vcfResonanceParam = new JenParameter(*this, "VCF resonance", 0.5));
    vcfResonanceParam->setValueNotifyingHost(0.5);
    
    addParameter(vcfLFOParam = new JenParameter(*this, "VCF LFO", 0.5));
    vcfLFOParam->setValueNotifyingHost(0.5);
    
    addParameter(vcfEnvLevelParam = new JenParameter(*this, "VCF env. level", 0.5));
    vcfEnvLevelParam->setValueNotifyingHost(0.5);
    
    addParameter(vcfAttackParam = new JenParameter(*this, "VCF attack", 0.3));
    vcfAttackParam->setValueNotifyingHost(0.3);
    
    addParameter(vcfDecayParam = new JenParameter(*this, "VCF decay", 0.3));
    vcfDecayParam->setValueNotifyingHost(0.3);
    
    addParameter(vcfSustainParam = new JenParameter(*this, "VCF sustain", 0.5));
    vcfSustainParam->setValueNotifyingHost(0.5);
    
    addParameter(vcfReleaseParam = new JenParameter(*this, "VCF release", 0.3));
    vcfReleaseParam->setValueNotifyingHost(0.3);
    
    //------- Noise Params ----------------------------------------------------
    
    addParameter(noiseNoiseParam = new JenParameter(*this, "NOISE noise", 0.5, 3));
    noiseNoiseParam->setValueNotifyingHost(0.5);
    
    addParameter(noiseLevelParam = new JenParameter(*this, "NOISE level", 0.5));
    noiseLevelParam->setValueNotifyingHost(0.5);
    
    //------- VCA Params ------------------------------------------------------
    
    addParameter(vcaOutputVolumeParam = new JenParameter(*this, "VCA level", 0.5));
    vcaOutputVolumeParam->setValueNotifyingHost(0.5);
    
    addParameter(vcaAttackParam = new JenParameter(*this, "VCA attack", 0.3));
    vcaAttackParam->setValueNotifyingHost(0.3);
    
    addParameter(vcaDecayParam = new JenParameter(*this, "VCA decay", 0.3));
    vcaDecayParam->setValueNotifyingHost(0.3);
    
    addParameter(vcaSustainParam = new JenParameter(*this, "VCA sustain", 0.5));
    vcaSustainParam->setValueNotifyingHost(0.5);
    
    addParameter(vcaReleaseParam = new JenParameter(*this, "VCA release", 0.3));
    vcaReleaseParam->setValueNotifyingHost(0.3);

    
    lfo.updateWave(Oscillator::TRIANGLE);
    lfo.updateFrequency(1);
    oscillator.updateFrequency(1);
    
    DBG("\n-- JenSx1000AudioProcessor constructor called\n");
}

JenSx1000AudioProcessor::~JenSx1000AudioProcessor()
{
}

//==============================================================================
const String JenSx1000AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String JenSx1000AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String JenSx1000AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool JenSx1000AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool JenSx1000AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool JenSx1000AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool JenSx1000AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool JenSx1000AudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double JenSx1000AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int JenSx1000AudioProcessor::getNumPrograms()
{
    return (int)FactoryPrograms::Programs::FACTORY_PROGRAMS_COUNT;
    // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int JenSx1000AudioProcessor::getCurrentProgram()
{
    return 0;
}

void JenSx1000AudioProcessor::setCurrentProgram (int index)
{
    Program* p = programs.getProgramPointer((FactoryPrograms::Programs)index);
    setProgram(p);
}

void JenSx1000AudioProcessor::setProgram (Program* p){
    
    vcoTuneParam->setValueNotifyingHost (p->vcoTune);
    vcoOctaveParam->setValueNotifyingHost (p->vcoOctave);
    vcoVibratoParam->setValueNotifyingHost (p->vcoVibrato);
    vcoWaveformParam->setValueNotifyingHost (p->vcoWaveform);
    vcoPulseWidthParam->setValueNotifyingHost (p->vcoPulseWidth);
    vcoPWMParam->setValueNotifyingHost (p->vcoPWM);
    vcoLevelParam->setValueNotifyingHost (p->vcoLevel);
    vcoGlideParam->setValueNotifyingHost (p->vcoGlide);
    
    //------- LFO --------------------------------------------------------------
    lfoSpeedParam->setValueNotifyingHost (p->lfoSpeed);
    
    //------- VCF --------------------------------------------------------------
    vcfFrequencyParam->setValueNotifyingHost (p->vcfFrequency);
    vcfResonanceParam->setValueNotifyingHost (p->vcfResonance);
    vcfLFOParam->setValueNotifyingHost (p->vcfLFO);
    vcfEnvLevelParam->setValueNotifyingHost (p->vcfEnvLevel);
    vcfAttackParam->setValueNotifyingHost (p->vcfAttack);
    vcfDecayParam->setValueNotifyingHost (p->vcfDecay);
    vcfSustainParam->setValueNotifyingHost (p->vcfSustain);
    vcfReleaseParam->setValueNotifyingHost (p->vcfRelease);
    
    //------- Noise ------------------------------------------------------------
    noiseNoiseParam->setValueNotifyingHost (p->noiseNoise);
    noiseLevelParam->setValueNotifyingHost (p->noiseLevel);
    
    //------- VCA --------------------------------------------------------------
    vcaOutputVolumeParam->setValueNotifyingHost (p->vcaOutputVolume);
    vcaAttackParam->setValueNotifyingHost (p->vcaAttack);
    vcaDecayParam->setValueNotifyingHost (p->vcaDecay);
    vcaSustainParam->setValueNotifyingHost (p->vcaSustain);
    vcaReleaseParam->setValueNotifyingHost (p->vcaRelease);
}

const String JenSx1000AudioProcessor::getProgramName (int index)
{
    return programs.getProgramPointer((FactoryPrograms::Programs)index) -> programName;
}

void JenSx1000AudioProcessor::changeProgramName (int index, const String& newName)
{
    programs.getProgramPointer((FactoryPrograms::Programs)index) -> programName = newName;
}

//==============================================================================
void JenSx1000AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    DBG("\n-- JenSx1000AudioProcessor::prepareToPlay called\n");
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    
    DBG("Sample Rate : " << sampleRate << "\n");
    DBG("Expected samples per block: " << samplesPerBlock << "\n");
    
    currentSampleRate = sampleRate;
    
    oscillator.updateSampleRate(currentSampleRate);
    lfo.updateSampleRate(currentSampleRate);
    
    // The following params are dependant on the sample rate, so need to be updated after sampleRate set
    // TODO: work out the propper way to do this i.e. if the sample rate changes whilst in use it should keep the same values
    vcoGlideParam->setValueNotifyingHost(0.5);
    vcaAttackParam->setValueNotifyingHost(0.3);
    vcaDecayParam->setValueNotifyingHost(0.3);
    vcaReleaseParam->setValueNotifyingHost(0.3);
    
    vcfAttackParam->setValueNotifyingHost(0.3);
    vcfDecayParam->setValueNotifyingHost(0.3);    
    vcfReleaseParam->setValueNotifyingHost(0.3);
}

void JenSx1000AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void JenSx1000AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    
    //DBG("\n-- JenSx1000AudioProcessor::processBlock called\n");
    
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    int time;
    MidiMessage m;
    
    for (MidiBuffer::Iterator i (midiMessages); i.getNextEvent (m, time);)
    {
        if (m.isNoteOn())
        {
            lastMidiNote = m.getNoteNumber();
            DBG("MIDI note triggered : " << lastMidiNote << "\n");
            freqControl.setNote(lastMidiNote);
            ampEnvelope.begin();
            vcf.begin();
        }
        else if (m.isNoteOff() & (m.getNoteNumber() == lastMidiNote))
        {
            ampEnvelope.release();
            vcf.release();
        }
        else if (m.isAftertouch())
        {
        }
        else if (m.isPitchWheel())
        {
        }
    }
    
    float* const firstChannelData = buffer.getWritePointer(0);
    
    for (int sample = 0; sample < buffer.getNumSamples(); ++sample){
        
        double nextLFOSample = lfo.getNextSample();
        freqControl.setNextVibratoOscSample(nextLFOSample);
        vcf.setNextLFOSample(nextLFOSample);
        oscillator.setNextPWMSample(nextLFOSample);
        
        oscillator.updateFrequency(freqControl.getNextFrequency());
        
        float nextSample = (vcf.processNextSample((oscillator.getNextSample() * vcoLevel) + (noise.getNextSample() * noiseLevel)) * ampEnvelope.getNextSample()) * ampLevel;
        
        jassert(nextSample <= 1);
        jassert(nextSample >= -1);
        
        firstChannelData[sample] = nextSample;
    }
    
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    /*
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);

        // ..do something to the data...
    }
     */
}

//==============================================================================
bool JenSx1000AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* JenSx1000AudioProcessor::createEditor()
{
    DBG("\n-- JenSx1000AudioProcessor::createEditor called\n");
    return new JenSx1000AudioProcessorEditor (*this);
}

void JenSx1000AudioProcessor::parameterChange(AudioProcessorParameter* param, float newValue){
    if (param == vcoTuneParam) {freqControl.setTuning((newValue * 24) - 12);}
    else if (param == vcoOctaveParam) {
        if (newValue == 1){freqControl.setOctave(FreqControl::FOUR);}
        else if (newValue > 0.66){freqControl.setOctave(FreqControl::EIGHT);}
        else if (newValue > 0.33){freqControl.setOctave(FreqControl::SIXTEEN);}
        else if (newValue == 0){freqControl.setOctave(FreqControl::THIRTY_TWO);}
        else {DBG("OCTAVE SETTING NOT KNOWN"); jassertfalse;}
    }
    else if (param == vcoVibratoParam) {freqControl.setVibratoAmount(newValue);}
    else if (param == vcoWaveformParam) {
        if (newValue == 0){oscillator.updateWave(Oscillator::SAW);}
        else if (newValue == 0.5){oscillator.updateWave(Oscillator::SQUARE);}
        else if (newValue == 1){oscillator.updateWave(Oscillator::PULSE);}
        else {DBG("WAVEFORM SETTING NOT KNOWN: " + (String)newValue + "\n"); jassertfalse;}
    }
    else if (param == vcoPulseWidthParam) {oscillator.setPulseWidth(((1 - newValue) * 45) + 5);}
    else if (param == vcoPWMParam) {oscillator.setPWMamount(newValue);}
    else if (param == vcoLevelParam) { vcoLevel = (newValue * 0.5); }
    else if (param == vcoGlideParam) { freqControl.setGlideTime(newValue * currentSampleRate * 2);}
    else if (param == lfoSpeedParam) {
        float lfoFrequency = newValue * 24.75 + 0.25;
        DBG("New LFO speed: " + (String)lfoFrequency); lfo.updateFrequency(lfoFrequency);
    }
    else if (param == vcfFrequencyParam) {vcf.setCutoff(newValue * 0.74 + 0.06);}
    else if (param == vcfResonanceParam) {vcf.setResonance(newValue);}
    else if (param == vcfLFOParam) {vcf.setLFOAmount(newValue);}
    else if (param == vcfEnvLevelParam) {vcf.setEnvLevel(newValue);}
    else if (param == vcfAttackParam) {vcf.setAttackTime(newValue * currentSampleRate * 2);}
    else if (param == vcfDecayParam) {vcf.setDecayTime(newValue * currentSampleRate * 2);}
    else if (param == vcfSustainParam) {vcf.setSustainAmplitude(newValue);}
    else if (param == vcfReleaseParam) {vcf.setReleaseTime(newValue * currentSampleRate * 2);}
    else if (param == noiseNoiseParam) {
        if (newValue == 0) {noise.setState(NoiseGen::OFF);}
        else if (newValue == 0.5) {noise.setState(NoiseGen::WHITE);}
        else if (newValue == 1) {noise.setState(NoiseGen::PINK);}
        else {DBG("NOISE SETTING NOT KNOWN: " + (String)newValue + "\n"); jassertfalse;}
    }
    else if (param == noiseLevelParam) {noiseLevel = newValue * 0.5;}
    else if (param == vcaOutputVolumeParam){ ampLevel = newValue; }
    else if (param == vcaAttackParam) {ampEnvelope.setAttackTime(newValue * currentSampleRate * 2);}
    else if (param == vcaDecayParam) {ampEnvelope.setDecayTime(newValue * currentSampleRate * 2);}
    else if (param == vcaSustainParam) {ampEnvelope.setSustainAmplitude(newValue);}
    else if (param == vcaReleaseParam) {ampEnvelope.setReleaseTime(newValue * currentSampleRate * 2);}
}

//==============================================================================
void JenSx1000AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    Program currentProgram("Current Program");
    
    currentProgram.vcoTune = vcoTuneParam->getValue();
    currentProgram.vcoOctave = vcoOctaveParam->getValue();
    currentProgram.vcoVibrato = vcoVibratoParam->getValue();
    currentProgram.vcoWaveform = vcoWaveformParam->getValue();
    currentProgram.vcoPulseWidth = vcoPulseWidthParam->getValue();
    currentProgram.vcoPWM = vcoPWMParam->getValue();
    currentProgram.vcoLevel = vcoLevelParam->getValue();
    currentProgram.vcoGlide = vcoGlideParam->getValue();
    currentProgram.lfoSpeed = lfoSpeedParam->getValue();
    currentProgram.vcfFrequency = vcfFrequencyParam->getValue();
    currentProgram.vcfResonance = vcfResonanceParam->getValue();
    currentProgram.vcfLFO = vcfLFOParam->getValue();
    currentProgram.vcfEnvLevel = vcfEnvLevelParam->getValue();
    currentProgram.vcfAttack = vcfAttackParam->getValue();
    currentProgram.vcfDecay = vcfDecayParam->getValue();
    currentProgram.vcfSustain = vcfSustainParam->getValue();
    currentProgram.vcfRelease = vcfReleaseParam->getValue();
    currentProgram.noiseNoise = noiseNoiseParam->getValue();
    currentProgram.noiseLevel = noiseLevelParam->getValue();
    currentProgram.vcaOutputVolume = vcaOutputVolumeParam->getValue();
    currentProgram.vcaAttack = vcaAttackParam->getValue();
    currentProgram.vcaDecay = vcaDecayParam->getValue();
    currentProgram.vcaSustain = vcaSustainParam->getValue();
    currentProgram.vcaRelease = vcaReleaseParam->getValue();
    
    copyXmlToBinary (currentProgram.getProgrameAsXmlElement(), destData);
}

void JenSx1000AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    
    Program* newProgram = new Program("New Program");
    
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    newProgram -> setProgramFromXml(xmlState);
    
    setProgram(newProgram);
    
    
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JenSx1000AudioProcessor();
}


